\documentclass[a4paper, 10pt, openright, parskip, chapterprefix]{scrreprt}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath, amsthm, amssymb, amscd, amsfonts, amsxtra}
\usepackage{graphicx}
\usepackage{epstopdf}

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\vspace{10mm}
\begin{center}
\includegraphics[height=20mm]{unilogo.eps}
\vfill
\rule{\textwidth}{0.1mm}\vspace{5mm}
\Huge\textbf{Parallele kontinuierliche Kollisionserkennung}
\vspace{1mm}\rule{\textwidth}{0.1mm}
\vfill
\Large
Ausarbeitung\\
Sebastian Brockmeyer und Dominik Krümpelmann
\vfill
\normalsize
Ausarbeitung  im Fachbereich Mathematik/Informatik an der Universität Osnabrück \\
Vorlesung: Parallele Algorithmen bei Henning Wenke

Osnabrück, den \today
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty}
\pagenumbering{Roman}
\chapter*{Einleitung}
\addcontentsline{toc}{chapter}{Einleitung}
\setcounter{page}{1}

\newpage
\mbox{}
\thispagestyle{empty}
\newpage
\clearpage
\setcounter{page}{2}
\tableofcontents
\listoffigures
\newpage


%% Beginn des Allgemeinen Teils
\pagenumbering{arabic}

\chapter{Grundlagen}
In diesem Kapitel werden wir uns mit den Timewarp Algoirthmus von~\cite{timewarp} beschäftigen und
Formeln für die Berechnung des exakten Zeitpunkts $t$ der Kollisionen herleiten, die von einem 
Objekttyp abhängig sind.
\section{Kollisionserkennung}

Für den Timewarp Algorithmus benötigen wir später den exakten Zeitpunkt einer Kollision. Da wir uns
auf den Objekttypen Kugel und Ebene beschränkten, reicht es für 2 mögliche Arten von Kollisionen 
(Kugel - Kugel und Kugel - Ebene) eine Formel herzuleiten.\\

\noindent Zunächst konzentrieren wir uns auf die Kugel - Kugel Kollision. Dafür benötigen wir die 2 Kugeln 
$s_1$ und $s_2$ zum gleichen Zeitpunkt, mit den Radien $s_1.r$ und $s_2.r$, den Geschwindigkeitsvektoren
$s_1.v$ und $s_2.v$ und die Positionen $s_1.p$ und $s_2.p$. Wir verwenden für die Abstandsberechnung die
Eulidnorm, da die Objekte sich im $\mathbb{R}^{3}$ befinden. Eine Kugel kollidiert mit einer anderen
Kugel, wenn 
\begin{equation}
    \label{eq:KugelKugelBed}
    \|s_1.p + s_1.v \cdot t - s_2.p - s_2.v \cdot t \|_{2} = s_1.r + s_2.r
\end{equation}
gilt, da der Abstand immer vom Ursprung der Kugel ausgeht.
Die Bedingung~\ref{eq:KugelKugelBed} können wir nun weiter vereinfachen, indem wir mit der Multilinearität des Skalarprodukts folgende Formel erhalten
\begin{align*}
(\ref{eq:KugelKugelBed})  &\Leftrightarrow \|\underbrace{s_1.p - s_2.p}_{=: s_{12}.p} + t (\underbrace{s_1.v - s_2.v}_{:=s_{12}v})\|_{2}  = s_1.r + s_2.r\\
&\Leftrightarrow \langle s_{12}.p + t \cdot s_{12}.v, s_{12}.p + t \cdot s_{12}.v\rangle = (s_1.r + s_2.r)^{2}\\
&\Leftrightarrow t^{2} \cdot \langle s_{12}.v, s_{12}.v\rangle + 2t \cdot \langle s_{12}.p, s_{12}.v\rangle + \langle s_{12}.p, s_{12}.p\rangle -(s_1.r+s_2.r)^{2} = 0 \text{.}
\end{align*}

\noindent Nun betrachten wir alle möglichen Fällte um $t$ exakt zu bestimmen. Zuerst betrachten wir den Fall $\langle s_{12}.v, s_{12}.v \rangle = 0$ und 
$\langle s_{12}.p, s_{12}.v \rangle = 0$. In diesem Fall können wir keine Zeitpunkt $t$ bestimmen, da alle $t$-Therme wegfallen. Wenn
$\langle s_{12}.v, s_{12}.v \rangle = 0$ und $\langle s_{12}.p, s_{12}.v\rangle \not= 0$, dann gilt
\begin{align*}
&2t \langle s_{12}.p, s_{12}.v\rangle + \langle s_{12}.p, s_{12}.p \rangle - (s_{1}.r + s_{2}.r)^{2} = 0 \\
\Leftrightarrow \; &t  = \frac{(s_{1}.r + s_{2}.r)^{2} - \langle s_{12}.p, s_{12}.p \rangle}{2 \langle s_{12}.p, s_{12}.p\rangle}\text{.}
\end{align*}

\noindent  Für den Fall, das $\langle s_{12}.v, s_{12}.v \rangle \not= 0$ können wir die PQ-Formel anwenden und erhalten
\begin{equation*}
t_{1, 2} = -\frac{\langle s_{12}.p, s_{12}.v\rangle}{\langle s_{12}.v, s_{12}.v \rangle} \pm \sqrt{ \left( \frac{\langle s_{12}.p, s_{12}.v\rangle}{\langle s_{12}.v, s_{12}.v \rangle} \right)^{2} + \frac{(s_{1}.r + s_{2}.r)^{2} + \langle s_{12}.p, s_{12}.p\rangle}{\langle s_{12}.v, s_{12}.v \rangle}}\text{.}
\end{equation*}

\noindent Damit können wir nun den Zeitpunkt der Kollision berechnen, wobei es bei mehreren Lösungen den nächsten Zeitpunkt gewählt wird und Zeitpunkte in der Vergangenheit werden missachtet. etzt bestimmen wir die Formel für die Ebene-Kugel Kollision.
\section{Timwarp Algorithmus}
\label{sec:TimewarpAlgoritmus}
    % * Timewarp Algorithmus
    %     ** Rollback
    %     ** Nachrichtensystem
    %     ** Kollisionserkennung
    %     ** Varianten (Hinweis auf Multi Body etc.)
    %     ** LVT/GVT




\chapter{Timewarp Algorithmus auf der GPU}
Der in Abschnitt \ref{sec:TimewarpAlgoritmus} vorgestellte Timewarp Algorithmus kann theoretisch von beliebig vielen Threads
parallel ausgef"uhrt werden. Jeder Thread berechnet dabei den zeitlichen Verlauf eines Objektes, indem er Events erkennt
und neue States erzeugt, anderen Threads Nachrichten schickt und seinerseits Nachrichten von anderen Threads empf"angt
und darauf reagiert. 

In diesem Kapitel wird vorgestellt, wie der Timewarp Algorithmus auf der GPU mittels CUDA implementiert wurde. Dabei wird
insbesondere auf Probleme eingegangen, die im Zuge der Implementierung aufgetreten sind, wie etwa die Umsetzung des
Nachrichtensystems oder die Implementierung geeigneter Datenstrukturen, die ohne dynamisch allokierten Speicher
auskommen. Denn es ist in CUDA zwar m"oglich, innerhalb eines Kernels Speicher dynamisch zu allokieren \cite{...}, aus
Gr"unden der Effizienz sollte darauf aber so weit wie m"oglich verzichtet werden.

Abschlie\ss end wird die im Rahmen des Praktikums entstandene Version des Timewarp Algorithmus vollst"andig illustriert
und erl"autert.

\section{Datenstrukturen}
\subsection{Dequeue}
Im Timewarp Algorithmus ist es erforderlich, dass die Threads States erzeugen, die die Zust"ande des ihnen zugewiesenen
Objektes repr"asentieren, und diese mit Zeitspempeln versehen zwischenspeichern, um ggf. einen Rollback zu einem
fr"uheren Zustand durchf"uhren zu k"onnen. Aus dem gleichen Grund m"ussen auch alle verschickten Nachrichten gespeichert
werden, um bei einem Rollback zugeh"orige Antimessages (vgl. \ref{...}) verschicken zu k"onnen.
Gespeicherte Zust"ande und Nachrichten, deren Zeitspempel "alter als die GVT sind, k"onnen dabei bedenkenlos gel"oscht
werden, da es keinen Rollback bis hinter die GVT geben kann.

Eine Datenstruktur, die diesen Anforderungen gerecht wird, ist eine Double-Ended-Queue, oder kurz "Dequeue". Diese wurde
nach dem Vorbild der \emph{ArraySchlange} aus der Vorlesung ''Informatik A'' \cite{...} an der Uni Osnabr"ueck
implementiert. Ihr Vorteil ist, dass sie auf einem Array fester Gr"o\ss e operiert und keinen dynamisch allokierten
Speicher ben"otigt. Dieser Vorteil ist allerdings zugleich auch ein Nachteil, da Queue sich bei Bedarf nicht ohne
Weiters vergr"o\ss ern kann. Es sei an dieser Stelle allerdings schon darauf hingewiesen, dass keine der eingesetzten
Dequeues in den Szenarien jemals eine Gr"o\ss e von f"unf "uberschritten hat, sodass eine feste Gr"o\ss e von 20
gew"ahlt wurde, um einerseits allen Eventualit"aten entgegenzukommen und andererseits nicht zu viel Speicher zu belegen.

\subsection{Heap}
Da ein Thread mehrere Nachrichten auf einmal bekommen kann, die er dann nach Zeitspempeln sortiert abarbeiten muss,
ben"otigt es auch hierf"ur eine geeignete Datenstruktur. Die Wahl fiehl hier auf einen Heap (vgl. \cite{...}), da der
Zugriff auf das kleinste Element in konstanter Zeit und ein Einf"uge- und L"oschvorgang in logarithmischer Zeit erfolgt.
Au\ss erdem kann er wie die Dequeue auf einem Array konstanter Gr"o\ss e arbeiten.
Die Tatsache, dass ein Heap immer nur ausschlie\ss lich den Zugriff und das L"oschen des kleinsten Elements erlaubt, ist
hier kein Nachteil, da jeder Thread immer nur eine eingehende Nachricht auf einmal bearbeitet und auch niemals Zugriff auf eine
andere als die mit dem kleinsten Zeitspempel ben"otigt.

\section{Das Nachrichtensystem}
\subsection{Nachrichten}


\chapter{Fazit}
\begin{thebibliography}{10}
\bibitem{timewarp}
Brian Mirtich. Timewarp Rigid Body Simulation. MERL - A MITSUBISHI ELECTRIC RESEARCH LABORATORY

\bibitem{timewarp-cpu}
John Koenig. Object-Centric Parallel Rigid Body Simulation With Timewarp. University of Minnesota
\end{thebibliography}
\end{document}



