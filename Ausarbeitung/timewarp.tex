\documentclass[a4paper, 10pt, openright, parskip, chapterprefix]{scrreprt}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath, amsthm, amssymb, amscd, amsfonts, amsxtra}
\usepackage{graphicx}
\usepackage{epstopdf}

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\vspace{10mm}
\begin{center}
\includegraphics[height=20mm]{unilogo.eps}
\vfill
\rule{\textwidth}{0.1mm}\vspace{5mm}
\Huge\textbf{Parallele kontinuierliche Kollisionserkennung}
\vspace{1mm}\rule{\textwidth}{0.1mm}
\vfill
\Large
Ausarbeitung\\
Sebastian Brockmeyer und Dominik Krümpelmann
\vfill
\normalsize
Ausarbeitung  im Fachbereich Mathematik/Informatik an der Universität Osnabrück \\
Vorlesung: Parallele Algorithmen bei Henning Wenke

Osnabrück, den \today
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty}
\pagenumbering{Roman}
\chapter*{Einleitung}
\addcontentsline{toc}{chapter}{Einleitung}
\setcounter{page}{1}

\newpage
\mbox{}
\thispagestyle{empty}
\newpage
\clearpage
\setcounter{page}{2}
\tableofcontents
\listoffigures
\newpage


%% Beginn des Allgemeinen Teils
\pagenumbering{arabic}

\chapter{Grundlagen}
In diesem Kapitel werden wir uns mit den Timewarp Algoirthmus von~\cite{timewarp} beschäftigen und
Formeln für die Berechnung des exakten Zeitpunkts $t$ der Kollisionen herleiten, die von einem 
Objekttyp abhängig sind.
\section{Kollisionserkennung}

Für den Timewarp Algorithmus benötigen wir später den exakten Zeitpunkt einer Kollision. Da wir uns
auf den Objekttypen Kugel und Ebene beschränkten, reicht es für 2 mögliche Arten von Kollisionen 
(Kugel - Kugel und Kugel - Ebene) eine Formel herzuleiten.\\

\subsection{Kugel - Kugel Kollision}
\noindent Zunächst konzentrieren wir uns auf die Kugel - Kugel Kollision. Dafür benötigen wir die 2 Kugeln 
$s_1$ und $s_2$ zum gleichen Zeitpunkt, mit den Radien $s_1.r$ und $s_2.r$, den Geschwindigkeitsvektoren
$s_1.v$ und $s_2.v$ und die Positionen $s_1.p$ und $s_2.p$. Wir verwenden für die Abstandsberechnung die
Eulidnorm, da die Objekte sich im $\mathbb{R}^{3}$ befinden. Eine Kugel kollidiert mit einer anderen
Kugel, wenn 
\begin{equation}
    \label{eq:KugelKugelBed}
    \|s_1.p + s_1.v \cdot t - s_2.p - s_2.v \cdot t \|_{2} = s_1.r + s_2.r
\end{equation}
gilt, da der Abstand immer vom Ursprung der Kugel ausgeht.
Die Bedingung~\ref{eq:KugelKugelBed} können wir nun weiter vereinfachen, indem wir mit der Multilinearität des Skalarprodukts folgende Formel erhalten
\begin{align*}
(\ref{eq:KugelKugelBed})  &\Leftrightarrow \|\underbrace{s_1.p - s_2.p}_{=: s_{12}.p} + t (\underbrace{s_1.v - s_2.v}_{:=s_{12}v})\|_{2}  = s_1.r + s_2.r\\
&\Leftrightarrow \langle s_{12}.p + t \cdot s_{12}.v, s_{12}.p + t \cdot s_{12}.v\rangle = (s_1.r + s_2.r)^{2}\\
&\Leftrightarrow t^{2} \cdot \langle s_{12}.v, s_{12}.v\rangle + 2t \cdot \langle s_{12}.p, s_{12}.v\rangle + \langle s_{12}.p, s_{12}.p\rangle -(s_1.r+s_2.r)^{2} = 0 \text{.}
\end{align*}

\noindent Nun betrachten wir alle möglichen Fällte um $t$ exakt zu bestimmen. Zuerst betrachten wir den Fall $\langle s_{12}.v, s_{12}.v \rangle = 0$ und 
$\langle s_{12}.p, s_{12}.v \rangle = 0$. In diesem Fall können wir keine Zeitpunkt $t$ bestimmen, da alle $t$-Therme wegfallen. Wenn
$\langle s_{12}.v, s_{12}.v \rangle = 0$ und $\langle s_{12}.p, s_{12}.v\rangle \not= 0$, dann gilt
\begin{align*}
&2t \langle s_{12}.p, s_{12}.v\rangle + \langle s_{12}.p, s_{12}.p \rangle - (s_{1}.r + s_{2}.r)^{2} = 0 \\
\Leftrightarrow \; &t  = \frac{(s_{1}.r + s_{2}.r)^{2} - \langle s_{12}.p, s_{12}.p \rangle}{2 \langle s_{12}.p, s_{12}.p\rangle}\text{.}
\end{align*}

\noindent  Für den Fall, das $\langle s_{12}.v, s_{12}.v \rangle \not= 0$ können wir die PQ-Formel anwenden und erhalten
\begin{equation*}
t_{1, 2} = -\frac{\langle s_{12}.p, s_{12}.v\rangle}{\langle s_{12}.v, s_{12}.v \rangle} \pm \sqrt{ \left( \frac{\langle s_{12}.p, s_{12}.v\rangle}{\langle s_{12}.v, s_{12}.v \rangle} \right)^{2} + \frac{(s_{1}.r + s_{2}.r)^{2} + \langle s_{12}.p, s_{12}.p\rangle}{\langle s_{12}.v, s_{12}.v \rangle}}\text{.}
\end{equation*}

\noindent Damit können wir nun den Zeitpunkt der Kollision berechnen, wobei es bei mehreren Lösungen den nächsten Zeitpunkt gewählt wird und Zeitpunkte in der Vergangenheit werden missachtet. 

\subsection{Kugel - Ebene Kollision}
Jetzt bestimmen wir die Formel für die Ebene-Kugel Kollision.
\section{Timwarp Algorithmus}
\label{sec:TimewarpAlgoritmus}
    % * Timewarp Algorithmus
    %     ** Rollback
    %     ** Nachrichtensystem
    %     ** Kollisionserkennung
    %     ** Varianten (Hinweis auf Multi Body etc.)
    %     ** LVT/GVT




\chapter{Timewarp Algorithmus auf der GPU}
Der in Abschnitt \ref{sec:TimewarpAlgoritmus} vorgestellte Timewarp Algorithmus kann theoretisch von beliebig vielen Threads
parallel ausgef"uhrt werden. Jeder Thread berechnet dabei den zeitlichen Verlauf eines Objektes, indem er Events erkennt
und neue States erzeugt, anderen Threads Nachrichten schickt und seinerseits Nachrichten von anderen Threads empf"angt
und darauf reagiert. 

In diesem Kapitel wird vorgestellt, wie der Timewarp Algorithmus auf der GPU mittels CUDA implementiert wurde. Dabei wird
insbesondere auf Probleme eingegangen, die im Zuge der Implementierung aufgetreten sind, wie etwa die Umsetzung des
Nachrichtensystems oder die Implementierung geeigneter Datenstrukturen, die ohne dynamisch allokierten Speicher
auskommen. Denn es ist in CUDA zwar m"oglich, innerhalb eines Kernels Speicher dynamisch zu allokieren \cite{...}, aus
Gr"unden der Effizienz sollte darauf aber so weit wie m"oglich verzichtet werden.

Abschlie\ss end wird die im Rahmen des Praktikums entstandene Version des Timewarp Algorithmus vollst"andig illustriert
und erl"autert.

\section{Datenstrukturen}
\subsection{Dequeue}
Im Timewarp Algorithmus ist es erforderlich, dass die Threads States erzeugen, die die Zust"ande des ihnen zugewiesenen
Objektes repr"asentieren, und diese mit Zeitstempeln versehen zwischenspeichern, um ggf. einen Rollback zu einem
fr"uheren Zustand durchf"uhren zu k"onnen. Aus dem gleichen Grund m"ussen auch alle verschickten Nachrichten gespeichert
werden, um bei einem Rollback zugeh"orige Antimessages (vgl. \ref{...}) verschicken zu k"onnen.
Gespeicherte Zust"ande und Nachrichten, deren Zeitstempel "alter als die GVT sind, k"onnen dabei bedenkenlos gel"oscht
werden, da es keinen Rollback bis hinter die GVT geben kann.

Eine Datenstruktur, die diesen Anforderungen gerecht wird, ist eine Double-Ended-Queue, oder kurz "Dequeue". Diese wurde
nach dem Vorbild der \emph{ArraySchlange} aus der Vorlesung ''Informatik A'' \cite{...} an der Uni Osnabr"ueck
implementiert. Ihr Vorteil ist, dass sie auf einem Array fester Gr"o\ss e operiert und keinen dynamisch allokierten
Speicher ben"otigt. Dieser Vorteil ist allerdings zugleich auch ein Nachteil, da Queue sich bei Bedarf nicht ohne
Weiters vergr"o\ss ern kann. Es sei an dieser Stelle allerdings schon darauf hingewiesen, dass keine der eingesetzten
Dequeues in den Szenarien jemals eine Gr"o\ss e von f"unf "uberschritten hat, sodass eine feste Gr"o\ss e von 20
gew"ahlt wurde, um einerseits allen Eventualit"aten entgegenzukommen und andererseits nicht zu viel Speicher zu belegen.

\subsection{Heap}
Da ein Thread mehrere Nachrichten auf einmal bekommen kann, die er dann nach Zeitstempeln sortiert abarbeiten muss,
ben"otigt es auch hierf"ur eine geeignete Datenstruktur. Die Wahl fiehl hier auf einen Heap (vgl. \cite{...}), da der
Zugriff auf das kleinste Element in konstanter Zeit und ein Einf"uge- und L"oschvorgang in logarithmischer Zeit erfolgt.
Au\ss erdem kann er wie die Dequeue auf einem Array konstanter Gr"o\ss e arbeiten.
Die Tatsache, dass ein Heap immer nur ausschlie\ss lich den Zugriff und das L"oschen des kleinsten Elements erlaubt, ist
hier kein Nachteil, da jeder Thread immer nur eine eingehende Nachricht auf einmal bearbeitet und auch niemals Zugriff auf eine
andere als die mit dem kleinsten Zeitstempel ben"otigt.

\section{Nachrichten}
Nachrichten spielen eine zentrale Rolle im Timewarp Algorithmus. In der hier implementierten Variante gibt es vier
unterschiedliche Nachrichtentypen, die aber den gleichen Aufbau haben.
\subsection{Aufbau einer Nachricht}
Eine Nachricht setzt sich aus folgenden Komponenten zusammen: Typ, Zeitstempel, Empf"anger-ID, Absender-ID und neuer
Zustand.

Dabei gibt es die folgenden vier verschiedenen Nachrichtentypen:
Events, Antievents, Event-Acknowledgements (ACK) und Event-Negative-Acknowledgements (NACK).

Die IDs von Empf"anger und Absender beziehen sich dabei jeweils direkt auf die globale ID des jeweiligen Threads. Der
neue Zustand wird nur ben"otigt, wenn es sich um eine Nachricht vom Typ Event handelt. Es handelt sich dabei de facto um
ein vollst"andiges Objekt mit Angaben "uber Position, Geschwindigkeit, Rotationsgeschwindigkeit und Rotationsstatus. Um
Nachrichten einheitlich verarbeiten zu k"onnen, enthalten auch die anderen Nachrichtentypen das Datenfeld des neuen
Zustands, wenngleich dieser dort g"anzlich ignoriert wird.

\subsection{Events}
Events werden immer dann verschickt, wenn ein Thread einen neuen Zustand seines Objektes erzeugt. Ist der Grund f"ur den
neuen Zustand eine Kollision mit einem anderen Objekt, wird ein Event an den Kollisionspartner geschickt mit dessen
neuen Zustand, um ihn "uber
die Kollision zu benachrichtigen. Wird dagegen eine Kollision mit einer Ebene erkannt oder findet in dem betrachteten
Zeitintervall (also zwischen zwei Rendervorg"angen) keine Kollision mehr statt, wird ebenfalls ein neuer Zustand
erzeugt, den der Thread mit einem Event an sich selbst verschickt. Dieses Vorgehen mag zun"achst umst"andlich erscheinen. Es ist aber
durchaus sinnvoll, da immer damit zu rechnen ist, auch noch Nachrichten mit einem kleineren Zeitstempel von anderen
Threads zu erhalten, die dann einen unn"otigen Rollback ausl"osen w"urden, sollte der neue Zustand zu voreilig akzeptiert
werden. Daher wird der eigene neue Zustand erst dann in die State-Queue eingef"ugt, wenn der Empf"anger mit einem ACK
geantwortet hat.

\subsection{Antievents}
Antievents bilden das Gegenst"uck zu Events. Sie sind zentraler Bestandteil des Rollback-Mechanismus. Empf"angt ein
Thread ein Event oder Antievent, dessen Zeitstempel kleiner ist als der des aktuellen Zustands, muss ein Rollback eingeleitet
werden. Das bedeutet einerseits, dass alle Zust"ande mit einem gr"o\ss eren Zeitstempel wieder aus der State-Queue gel"oscht werden m"ussen, und
andererseits, dass alle verschickten Events mit einem gr"o\ss eren Zeitstempel f"ur ung"ultig erkl"art werden m"ussen.
Die Empf"anger dieser Events werden daher mit
zugeh"origen Antievents "uber diese Situation informiert, sodass sie dann ihrerseits einen Rollback einleiten k"onnen.

\subsection{Event-Acknowledgement}
Ein ACK ist die Antwort auf ein Event. Ein Thread, der ein Event empfangen hat und den darin enthaltenen Zustand in
seine State-Queue einf"ugt, muss daraufhin ein ACK an der Absender des Events schicken. Dieser kann daraufhin
ebenfalls den neuen Zustand in seine State-Queue einf"ugen.

\subsection{Event-Negative-Acknowledgement}
Ein NACK wird verschickt, wenn der Empf"anger eines Events dieses verwirft. Das kann w"ahrend eines Rollbacks geschehen,
da dort die gesamte Input-Queue gel"oscht wird. Der Absender des Events muss dann beim Empfang des zugeh"origen NACKs
ebenfalls den erzeugten Zustand, der noch nicht in seine State-Queue eingef"ugt wurde, verwerfen.

\subsection{Das Verschicken von Nachrichten}
\label{subsec:VerschickenVonNachrichten}
Das Verschicken von Nachrichten ist auf der GPU eine Herausforderung. Da es oft vorkommen kann, dass ein Thread
gleichzeitig mehrere Nachrichten von unterschiedlichen anderen Threads bekommt, die dann in einen Heap eingef"ugt werden
m"ussen, um sie chronologisch bearbeiten zu k"onnen, muss eine geeignete Synchronisierung
benutzt werden. 

In dieser Implementierung wurde dieses Problem so gel"ost, dass jeder Thread eine Queue f"ur die zu verschickenden
Nachrichten zugesprochen bekommt, die sogenannte \emph{Mailbox}. Verschickt ein Thread eine Nachricht, so tut er dies,
indem er sie in seine Mailbox einf"ugt.
In einem weiteren
Kernel durchsucht dann jeder Thread die Mailboxes aller anderen Threads nach Nachrichten, die an ihn addressiert sind
und f"ugt sie in seinen Heap ein. Dabei besteht dann keine Gefahr von Schreibkonfilkten zwischen den Threads.


\section{Kernelaufbau}
\label{sec:Kernelaufbau}
Der komplette Timewarp Algorithmus wurde auf mehrere Kernel aufgeteilt, um globale Synchronisationspunkte zu setzen, die
insbesondere f"ur das Nachrichtensystem von Bedeutung sind (vgl. \ref{subsec:VerschickenVonNachrichten}).
Diese Kernelaufrufe finden jeweils zwischen zwei Renderschritten in einer Schleife statt, die so lange durchlaufen wird,
bis die GVT das vorgegebene Zeitintervall $dt$ (in der Regel ca. 60ms) erreicht hat.

\subsection{Kernel zur Kollisionserkennung}
Am Anfang der Schleife wird ein Kernel zur Kollisionserkennung aufgerufen. Dort pr"uft jeder Thread, mit welcher Ebene
bzw. welcher anderen Kugel seine vorderste Kugel in der State-Queue als n"achstes kollidiert. Dabei ist
darauf zu achten, dass nicht nur die vordersten States der anderen State-Queues beachtet werden, sondern alle mit einem
gr"o\ss eren Zeitstempel als die eigene LVT, sodass es ggf. zum Rollback kommen kann. Der Zeitpunkt der n"achsten
Kollision wird gespeichert und bez"uglich dieser Zeit werden neue Zust"ande der beiden Kollisionspartner erzeugt. Das
hei\ss t, dass sie um diese Zeit entsprechend ihrer Geschwindigkeit bewegt werden, um dann die Kollisionsbehandlung
durchzuf"uhren. Die So erzeugten Kugeln repr"asentieren den Zustand unmittlebar nach der Kollision.

Der eigene neue Zustand wird zwischengespeichert, um ihn im Falles eines ACKs in die State-Queue einzuf"ugen. Der neue
Zustand des Kollisionspartners wir mittels eines Events an diesen verschickt.

F"ur den Fall, dass der n"achste Kollisionspartner eine Ebene ist oder im Zeitintervall $dt$ keine weiteren Kollisionen
stattfinden, wird der neue Zustand unmittlebar nach der Kollision bzw. zum Zeitpunkt $dt$ mittels eines Events an sich
selbst verschickt.

\subsection{Reagieren auf Nachrichten}
Wann immer Nachrichten verschickt worden sind, muss nach ihrer Zustellung ein Kernel aufgerufen werden, der die
Nachrichten bearbeitet. Durch den Heap als Datenstruktur ist eine zeitlich korrekte abfolge dabei automatisch gegeben.

Jeder Thread betrachtet sukzessive alle Nachrichten im Heap. Sollte er dabei feststellen, dass ein Event und ein
zugeh"origes Antievent direkt aufeinander folgen, k"onnen beide direkt gel"oscht werden, da sie sich gegenseitig
aufheben.

Andernfalls muss abh"angig vom Nachrichtentyp reagiert werden.

\subsection{Reagieren auf Events}
Wird ein Event empfangen, muss zun"achst, falls dessen Zeitstempel vor der eigenen LVT liegt, 
ein Rollback stattfinden (vgl. \ref{...}), bevor der mit dem Event gesendete
Zustand in die State-Queue eingef"ugt werden kann. Anschlie\ss end muss ein ACK an den Absender gesendet werden, falls
der Absender nicht der Thread selbst ist, da in diesem Fall der neue Zustand soeben
bereits hinzugef"ugt wurde und das ACK diese Aufgabe somit nicht mehr "ubernehmen muss.



\chapter{Fazit}
\begin{thebibliography}{10}
\bibitem{timewarp}
Brian Mirtich. Timewarp Rigid Body Simulation. MERL - A MITSUBISHI ELECTRIC RESEARCH LABORATORY

\bibitem{timewarp-cpu}
John Koenig. Object-Centric Parallel Rigid Body Simulation With Timewarp. University of Minnesota
\end{thebibliography}
\end{document}



