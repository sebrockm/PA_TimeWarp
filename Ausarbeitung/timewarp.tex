\documentclass[a4paper, 10pt, openright, parskip, chapterprefix]{scrreprt}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath, amsthm, amssymb, amscd, amsfonts, amsxtra}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{tikz}


\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\vspace{10mm}
\begin{center}
\includegraphics[height=20mm]{unilogo.eps}
\vfill
\rule{\textwidth}{0.1mm}\vspace{5mm}
\Huge\textbf{Parallele kontinuierliche Kollisionserkennung}
\vspace{1mm}\rule{\textwidth}{0.1mm}
\vfill
\Large
Ausarbeitung\\
Sebastian Brockmeyer und Dominik Krümpelmann
\vfill
\normalsize
Ausarbeitung  im Fachbereich Mathematik/Informatik an der Universität Osnabrück \\
Vorlesung: Parallele Algorithmen bei Henning Wenke

Osnabrück, den \today
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty}
\pagenumbering{Roman}
\chapter*{Einleitung}
\addcontentsline{toc}{chapter}{Einleitung}
\setcounter{page}{1}

\newpage
\mbox{}
\thispagestyle{empty}
\newpage
\clearpage
\setcounter{page}{2}
\tableofcontents
\listoffigures
\newpage


%% Beginn des Allgemeinen Teils
\pagenumbering{arabic}

\chapter{Grundlagen}
In diesem Kapitel werden wir uns mit dem Timewarp Algoirthmus von~\cite{timewarp} beschäftigen und
Formeln für die Berechnung des exakten Zeitpunkts $t$ der Kollisionen herleiten, die von einem 
Objekttyp abhängig sind.

\section{Kollisionserkennung}
Die Berechnung des exakten Zeitpunktes benötigen wir, um eine exakte Kollisionserkennung zu garantieren. Das heißt die Kollisionen werden vor dem eigentlichen Kollisionszeitpunkt erkannt. Dadurch erhalten wir eine kontinuierliche Kollisionserkennung und vermeiden eine diskrete Kollisionserkennung (siehe Abbildung~\ref{abb:kollkondis}).

\begin{figure}[h!]
\centering\begin{tikzpicture}
\draw[blue] (-4,0) circle (12pt);
\draw[red] (-3 -1/7 ,0) circle (12pt);
\filldraw[draw=black,color=blue] (-4,-0) circle (12pt);
\filldraw[draw=black,color=red] (-3 -1/7,0) circle (12pt);
\draw (-3.6, -1) node{kontinuierlich};
\draw (2.3, -1) node{diskret};
\draw[green] (2,0) circle (12pt);
\draw[black] (3-1/2,0) circle (12pt);
\filldraw[draw=black,color=green] (2,0) circle (12pt);
\filldraw[draw=black,color=black] (3-1/2,0) circle (12pt);
\end{tikzpicture}
\caption{Kollisionserkennungsarten}
\label{abb:kollkondis}
\end{figure}

Da wir uns auf den Objekttypen Kugel und Ebene beschränkten, reicht es für 2 mögliche Arten von Kollisionen 
(Kugel - Kugel und Kugel - Ebene) eine Formel herzuleiten.\\

\subsection{Kugel - Kugel Kollision}
\noindent Zunächst konzentrieren wir uns auf die Kugel - Kugel Kollision. Dafür benötigen wir die 2 Kugeln 
$s_1$ und $s_2$ zu einem gleichen Zeitpunkt, mit den Radien $s_1.r$ und $s_2.r$, den Geschwindigkeitsvektoren
$s_1.v$ und $s_2.v$ und die Positionen $s_1.p$ und $s_2.p$. Wir verwenden für die Abstandsberechnung die
Euklidnorm, da die Objekte sich im $\mathbb{R}^{3}$ befinden. Eine Kugel kollidiert mit einer anderen
Kugel, wenn 
\begin{equation}
    \label{eq:KugelKugelBed}
    \|s_1.p + s_1.v \cdot t - s_2.p - s_2.v \cdot t \|_{2} = s_1.r + s_2.r
\end{equation}
gilt, da der Abstand immer vom Zentrum der Kugel gemessen wird.
Die Bedingung~\ref{eq:KugelKugelBed} können wir nun weiter vereinfachen, indem wir mit der Multilinearität des Skalarprodukts verwenden. Damit erhalten wir die Formel 
\begin{align*}
(\ref{eq:KugelKugelBed})  &\Leftrightarrow \|\underbrace{s_1.p - s_2.p}_{=: s_{12}.p} + t (\underbrace{s_1.v - s_2.v}_{:=s_{12}v})\|_{2}  = s_1.r + s_2.r\\
&\Leftrightarrow \langle s_{12}.p + t \cdot s_{12}.v, s_{12}.p + t \cdot s_{12}.v\rangle = (s_1.r + s_2.r)^{2}\\
&\Leftrightarrow t^{2} \cdot \langle s_{12}.v, s_{12}.v\rangle + 2t \cdot \langle s_{12}.p, s_{12}.v\rangle + \langle s_{12}.p, s_{12}.p\rangle -(s_1.r+s_2.r)^{2} = 0 \text{.}
\end{align*}

\noindent Nun betrachten wir alle möglichen Fälle um $t$ exakt zu bestimmen. Zuerst betrachten wir den Fall $\langle s_{12}.v, s_{12}.v \rangle = 0$ und $\langle s_{12}.p, s_{12}.v \rangle = 0$. In diesem Fall können wir keinen Zeitpunkt $t$ bestimmen, da alle $t$-Therme wegfallen. Wenn
$\langle s_{12}.v, s_{12}.v \rangle = 0$ und $\langle s_{12}.p, s_{12}.v\rangle \not= 0$, dann gilt
\begin{align*}
&2t \langle s_{12}.p, s_{12}.v\rangle + \langle s_{12}.p, s_{12}.p \rangle - (s_{1}.r + s_{2}.r)^{2} = 0 \\
\Leftrightarrow \; &t  = \frac{(s_{1}.r + s_{2}.r)^{2} - \langle s_{12}.p, s_{12}.p \rangle}{2 \langle s_{12}.p, s_{12}.p\rangle}\text{.}
\end{align*}

\noindent  Für den Fall, das $\langle s_{12}.v, s_{12}.v \rangle \not= 0$ ist, können wir die PQ-Formel anwenden und erhalten
\begin{equation*}
t_{1, 2} = -\frac{\langle s_{12}.p, s_{12}.v\rangle}{\langle s_{12}.v, s_{12}.v \rangle} \pm \sqrt{ \left( \frac{\langle s_{12}.p, s_{12}.v\rangle}{\langle s_{12}.v, s_{12}.v \rangle} \right)^{2} + \frac{(s_{1}.r + s_{2}.r)^{2} + \langle s_{12}.p, s_{12}.p\rangle}{\langle s_{12}.v, s_{12}.v \rangle}}\text{.}
\end{equation*}

\noindent Damit können wir nun den Zeitpunkt der Kollision berechnen, wobei es bei mehreren Lösungen der älteste Zeitpunkt gewählt wird. Natürlich werden Zeitpunkte, die in der Vergangenheit liegen, missachtet. 

\subsection{Kugel - Ebene Kollision}
Jetzt bestimmen wir die Formel für die Ebene-Kugel Kollision. Dafür benötigen wir eine Ebene $e$ und eine Kugel $s$.  Da für die Ebene die Hessenormalform verwendet, reicht es folgende Bedingung 
\begin{equation}
	\langle s.x, e.n \rangle - e.d = s.r
	\label{eq:bedEbeneKugel}
\end{equation}
nach $t$ umzuformen. Für die Umformung nach $t$ verwenden wir wieder die Multilinearität. Damit ergibt sich
\begin{align*}
(\ref{eq:bedEbeneKugel}) &\Leftrightarrow \langle s.p, e.n \rangle + \langle s.v \cdot t, e.n \rangle - e.d = s.r \\
&\Leftrightarrow \langle s.p, e.n \rangle + t \cdot \langle s.v, e.n\rangle - e.d = s.r\\
&\Leftrightarrow t = \frac{s.r + e.d - \langle s.p, e.n \rangle}{ \langle s.v, s.n \rangle}\text{.}
\end{align*}
\section{Timwarp Algorithmus}
\label{sec:TimewarpAlgoritmus}

In diesem Abschnitt werden wir eine mögliche Strategie für die Kollisionserkennung vorstellen. Natürlich  stellt sich die Frage, warum wir nicht ein naiven Ansatz für Kollisionserkennung verwenden. Das Problem ist, dass mit einem naiven Ansatz die Situation von Abbildung~\ref{abb:kollision} eintreten kann.

\begin{figure}[h!]
\centering\begin{tikzpicture}
\draw[blue] (-4,0) circle (12pt);
\draw[red] (4,0) circle (12pt);
\draw[green] (2,2) circle (12pt);
\draw[gray] (0,0) circle (12pt);
\draw[gray] (2,0) circle (12pt);
\draw[line width=0.5mm, ->, dashed] (-4,0) -- (-3,0);
\draw[line width=0.5mm, ->, dashed] (4,0) -- (3,0);
\draw[line width=0.5mm, ->, dashed] (2,2) -- (2,1);
\filldraw[draw=black,color=blue] (-4,-0) circle (12pt);
\filldraw[draw=black,color=red] (4,0) circle (12pt);
\filldraw[draw=black,color=green] (2,2) circle (12pt);
\filldraw[draw=black,color=gray] (0,0) circle (12pt);
\filldraw[draw=black,color=gray] (2,0) circle (12pt);
\draw (-5, 0) node{$s_1$};
\draw (5, 0) node{$s_3$};
\draw (2, 3) node{$s_2$};
\draw (0, -1) node{$t = 1$};
\draw (2, -1) node{$t = 0.5$};
\end{tikzpicture}
\caption{Kollisionsproblem}
\label{abb:kollision}
\end{figure}

In diesem Szenario ist zu erkennen, das bei einer paralellen Überprüfung die Kugel $s_1$ eine Kollision mit $s_3$ erkennt. Jedoch $s_3$ eigentlich mit $s_2$ kollidiert und die erkannte Kollision von $s_1$ nicht eintreten wird.  Dieses Problem werden wir nun mit der Timewarp Ridgid Body Simulation von~\cite{timewarp} lösen, wobei diese Version den Allgemeinen Timewarp Algorithmus von~\cite{jefferson} verwendet. Dieser allgemeine Algorithmus ist eine mögliche Strategie für parallele diskrete Event Simulation.\\
Wir werden uns auf Kugel - Kugel Kollision beschränken, da die Ebene sich nicht bewegt. Das heißt die Kugel - Ebene Kollision ist immer eindeutig und es kann kein Fall wie in Abbildung~\ref{abb:kollision} eintreten. 

\subsection{Was repräsentiert ein Prozess?}
Jeder Prozess repräsentiert eine Kugel, wobei dieser eine lokale virtuelle Zeit (LVT) besitzt. Diese LVT wird für die eigentliche Kollisionserkennung verwendet. Falls eine Kollision erkannt und akzeptiert wurde, speichern wir diese mit einem Zeitstempel in der sogenannten $stateQ$. Außerdem wird der LVT auf den Zeitstempel der eigefügten Kollision erhöht. Das Minimum aller LVTs bezeichnen wir als globale virtuelle Zeit (GVT).


In unseren Simulation nehmen wir an, dass wir keine verbundenen Objekte haben. Jeder Prozess repräsentiert ein Objekt und hat eine lokale virtuelle Zeit (LVT). Außerdem besitzt jedes Objekt eine $stateQueue$. In dieser Queue werden alle möglichen Kollisionen mit einem Zeitstempel gespeichert. Zur Verifizierung und Kommunikation zwischen den einzelnen Objekten werden Events verwendet. Wir benötigen vier Arten von Events:
\begin{enumerate}
\item Kollisionskontrolle (EVENT)
\item Rollback (ANTIEVENT)
\item Bestätigung (ACK)
\item Absagen (NACK)
\end{enumerate}
Diese Event - Nachrichten sind der wesentliche Bestandteil des Algorithmus, da dadurch das Problem aus Abb~\ref{abb:kollision} verhindert wird.
\subsection{Rollback}
\subsection{Event}
\subsection{AntiEvent}
\subsection{LVT / GVT}
    % * Timewarp Algorithmus
    %     ** Rollback
    %     ** Nachrichtensystem
    %     ** Kollisionserkennung
    %     ** Varianten (Hinweis auf Multi Body etc.)
    %     ** LVT/GVT





\chapter{Timewarp Algorithmus auf der GPU}
Der in Abschnitt \ref{sec:TimewarpAlgoritmus} vorgestellte Timewarp Algorithmus kann theoretisch von beliebig vielen Threads
parallel ausgef"uhrt werden. Jeder Thread berechnet dabei den zeitlichen Verlauf eines Objektes, indem er Events erkennt
und neue States erzeugt, anderen Threads Nachrichten schickt und seinerseits Nachrichten von anderen Threads empf"angt
und darauf reagiert. 

In unserem Fall handelt es sich bei den Objekten ausschlie\ss lich um Kugeln und Ebenen, wobei sich die Ebenen nicht
bewegen und somit auch keinen eigenen Thread ben"otigen, der ihre Bewegung durch die Szene verwaltet.

In diesem Kapitel wird vorgestellt, wie der Timewarp Algorithmus auf der GPU mittels CUDA implementiert wurde. Dabei wird
insbesondere auf Probleme eingegangen, die im Zuge der Implementierung aufgetreten sind, wie etwa die Umsetzung des
Nachrichtensystems oder die Implementierung geeigneter Datenstrukturen, die ohne dynamisch allokierten Speicher
auskommen.

Abschlie\ss end wird die im Rahmen des Praktikums entstandene Version des Timewarp Algorithmus vollst"andig illustriert
und erl"autert.

\section{Datenstrukturen}
\subsection{Dequeue}
Im Timewarp Algorithmus ist es erforderlich, dass die Threads Zust"ande erzeugen, die den zeitlichen Werdegang der ihnen zugewiesenen
Kugel repr"asentieren. Diese werden mit Zeitstempeln versehen und nach diesen geordnet zwischengespeichert, um ggf. einen Rollback zu einem
fr"uheren Zustand durchf"uhren zu k"onnen. Aus dem gleichen Grund m"ussen auch Antievents zu allen verschickten Events gespeichert
werden, um sie bei einem Rollback (vgl. \ref{subsec:Rollback}) verschicken zu k"onnen.
Gespeicherte Zust"ande und Nachrichten, deren Zeitstempel "alter als die GVT sind, k"onnen dabei bedenkenlos gel"oscht
werden, da es keinen Rollback bis hinter die GVT geben kann.

Eine Datenstruktur, die diesen Anforderungen gerecht wird, ist eine Double-Ended-Queue, oder kurz "Dequeue". Diese wurde
nach dem Vorbild der \emph{ArraySchlange} aus der Vorlesung ''Informatik A'' \cite{...} an der Uni Osnabr"ueck
implementiert. Ihr Vorteil ist, dass sie auf einem Array fester Gr"o\ss e operiert und keinen dynamisch allokierten
Speicher ben"otigt. Dieser Vorteil ist allerdings zugleich auch ein Nachteil, da Queue sich bei Bedarf nicht ohne
Weiters vergr"o\ss ern kann. Es sei an dieser Stelle allerdings schon darauf hingewiesen, dass keine der eingesetzten
Dequeues in den Szenarien jemals eine Gr"o\ss e von f"unf "uberschritten hat, sodass eine feste Gr"o\ss e von 20
gew"ahlt wurde, um einerseits allen Eventualit"aten entgegenzukommen und andererseits nicht zu viel Speicher zu belegen.
Ein weiterer Vorteil ist, dass auf jedes Element in konstanter Zeit zugegriffen werden kann. Ebenfalls in konstanter
Zeit kann ein L"osch- oder Einf"ugevorgang am Anfang und am Ende der Dequeue durchgef"uhrt werden.

\subsection{Heap}
Da ein Thread mehrere Nachrichten auf einmal bekommen kann, die er dann nach Zeitstempeln sortiert abarbeiten muss,
ben"otigt es auch hierf"ur eine geeignete Datenstruktur. Die Wahl fiehl hier auf einen Heap (vgl. \cite{...}), da der
Zugriff auf das kleinste Element in konstanter Zeit und ein Einf"uge- und L"oschvorgang in logarithmischer Zeit erfolgt.
Au\ss erdem kann er wie die Dequeue auf einem Array konstanter Gr"o\ss e arbeiten.
Die Tatsache, dass ein Heap immer nur ausschlie\ss lich den Zugriff und das L"oschen des kleinsten Elements erlaubt, ist
hier kein Nachteil, da jeder Thread immer nur eine eingehende Nachricht auf einmal bearbeitet und auch niemals Zugriff auf eine
andere als die mit dem kleinsten Zeitstempel ben"otigt.

\section{Kernelaufbau}
\label{sec:Kernelaufbau}
Der komplette Timewarp Algorithmus wurde auf mehrere Kernel aufgeteilt, um globale Synchronisationspunkte zu setzen, die
insbesondere f"ur das Nachrichtensystem von Bedeutung sind. 
Diese Kernelaufrufe finden jeweils zwischen zwei Renderschritten in einer Schleife statt, die so lange durchlaufen wird,
bis die GVT das vorgegebene Zeitintervall $dt$ (in der Regel ca. 60ms) erreicht hat.

\subsection{Verschicken von Nachrichten}
\label{subsec:VerschickenVonNachrichten}
Das Verschicken von Nachrichten ist auf der GPU eine Herausforderung. Es ist nicht ohne Weiteres m"oglich, eine zu sendende
Nachricht direkt in den Heap des Empf"angers einzuf"ugen, da auch andere Threads dies zur gleichen Zeit durchf"uhren
k"onnten, was zu Schreibkonfilkten f"uhren w"urde.

In dieser Implementierung wurde dieses Problem so gel"ost, dass jeder Thread eine Queue f"ur die zu verschickenden
Nachrichten zugesprochen bekommt, die sogenannte \emph{Mailbox}. Wann immer wir vom Verschicken einer Nachricht
sprechen, so bedeutet dies, dass die Nachricht zun"achst lediglich in die eigene Mailbox eingef"ugt wird.
In einem separaten
Kernel \emph{''receiveFromMailboxes''} durchsucht dann jeder Thread die Mailboxes aller anderen Threads nach
Nachrichten, die an ihn addressiert sind,
und f"ugt sie in seinen eigenen Heap ein. Dabei besteht keine Gefahr von Schreibkonfilkten zwischen den Threads.
Ein offensichtlicher Nachteil ist die Laufzeit.

Nach dem Aufruf von \emph{''receiveFromMailboxes''} m"ussen die Mailboxes wieder geleert werden. Aus
Synchronisationsgr"unden geschieht dies in einem eigenen Kernel \emph{''clearMailboxes''}. Das Leeren einer Dequeue
erfolgt in konstanter Zeit.


\subsection{Kernel zur Kollisionserkennung}
\label{subsec:KernelZurKollisionserkennung}
Am Anfang der Schleife wird ein Kernel \emph{''detectCollisions''} zur Kollisionserkennung aufgerufen. Dort pr"uft jeder Thread, mit welcher Ebene
bzw. welcher anderen Kugel das Front-Element seiner State-Queue als n"achstes kollidiert. Dabei ist
darauf zu achten, alle Eintr"age der anderen State-Queues mit einem
gr"o\ss eren Zeitstempel als der eigenen LVT zu betrachten, sodass es ggf. zum Rollback kommen kann. Der Zeitpunkt der n"achsten
Kollision wird gespeichert und bez"uglich dieser Zeit werden neue Zust"ande der beiden Kollisionspartner erzeugt. Das
hei\ss t, dass sie um diese Zeit entsprechend ihrer Geschwindigkeit bewegt werden, um dann an diesen Positionen, an
denen sie sich so eben ber"uhren, die Kollisionsbehandlung
durchzuf"uhren. Die So erzeugten Kugeln repr"asentieren den Zustand unmittlebar nach der Kollision.

Der eigene neue Zustand wird zwischengespeichert, aber noch nicht in die State-Queue eingef"ugt (s.a. Abschnitt
\ref{subsubsed:ReagierenAufACKs}. Der neue
Zustand des Kollisionspartners wird mittels eines Events an diesen verschickt. Direkt nach dem Versenden des Events muss
ein zugeh"origes Antievent in die sogenannte Output-Queue eingef"ugt werden. Diese Queue kommt beim Rollback (vgl.
Abschnitt \ref{subsec:Rollback}) zum Einsatz, wenn versandte Events mit Antievents wieder r"uckg"angig gemacht werden
m"ussen.

F"ur den Fall, dass der n"achste Kollisionspartner eine Ebene ist oder im Zeitintervall $dt$ keine weiteren Kollisionen
erkannt werden, erzeugt der Thread den neuen Zustand unmittlebar nach der Kollision bzw. zum Zeitpunkt $dt$ und schickt
ihn mittels eines Events an sich selbst.

\subsection{Reagieren auf Nachrichten}
Wann immer Nachrichten verschickt worden sind, muss nach ihrer Zustellung ein Kernel \emph{''handleNextMessages''} aufgerufen werden, der die
Nachrichten bearbeitet. Durch den Heap als Datenstruktur ist eine zeitlich korrekte Abfolge dabei automatisch gegeben.

Jeder Thread betrachtet sukzessive alle Nachrichten im Heap. Sollte er dabei feststellen, dass ein Event und ein
zugeh"origes Antievent direkt aufeinander folgen, k"onnen beide direkt gel"oscht werden, da sie sich gegenseitig
aufheben.

Andernfalls muss abh"angig vom Nachrichtentyp reagiert werden.

\subsubsection{Reagieren auf Events}
Wird ein Event empfangen, muss zun"achst, falls dessen Zeitstempel vor der eigenen LVT liegt, 
ein Rollback stattfinden (s. \ref{subsec:Rollback}), bevor der mit dem Event gesendete
Zustand in die State-Queue eingef"ugt werden kann. Ist der Absender des Events ein anderer Thread (das Event
benachrichtigt also "uber die Kollision zweier Kugeln), muss ein ACK an den Absender gesendet werden. Andernfalls, wenn
das Event vom Thread an sich selbst gesendet wurde, entf"allt die Notwendigkeit eines ACKs, da in diesem Fall der neue Zustand soeben
bereits hinzugef"ugt wurde und das ACK diese Aufgabe somit nicht mehr "ubernehmen muss.

\subsubsection{Reagieren auf Antievents}
Beim Empfang eines Antievents muss der Zustand in der State-Queue gesucht werden, der aufgrund des zugeh"origen Events
dort eingef"ugt wurde. Ein Rollback muss dann diesen Zustand sowie alle folgenden Zust"ande in der State-Queue
l"oschen.

\subsubsection{Reagieren auf ACKs}
\label{subsubsed:ReagierenAufACKs}
Wird ein ACK empfangen, muss zuvor ein Event verschickt worden sein. Der neue Zustand, der beim Schicken dieses
Events zwischengespeichert wurde (s. \ref{subsec:KernelZurKollisionserkennung}), kann nun in die State-Queue eingef"ugt
werden, wenn er nicht zuvor z.B. durch einen Rollback gel"oscht wurde.

\subsubsection{Reagieren auf NACKs}
Wie ein ACK kann auch ein empfangenes NACK nur die Folge eines zuvor verschickten Events sein. Der zwischengespeicherte
Zustand muss dann einfach gel"oscht werden.

\subsection{Berechnung der GVT}
Ziel des Timewarp Algorithmus ist, dass die GVT den den Wert des Zeitintervalls zwischen zwei Rendervorg"angen $dt$
erreicht. Um die GVT zu berechnen, m"ussen zun"achst alle LVTs ermittelt werden. Diese Aufgabe "ubernimmt ein Kernel
\emph{''calculateLVT''}, in dem jeder Thread seine eigene LVT, also das Minimum aus den beiden Zeitstempeln der
n"achsten Nachricht im Heap und des j"ungsten Zustands der State-Queue, in ein Array schreibt. Mittels einer Reduktion
wird dann die kleinste dieser LVTs, also die GVT, ermittelt.

In einem weiteren Kernel \emph{''deletOlderThanGVT''} werden dann alle Zust"ande und Nachrichten der State-Queues und
Output-Queues gel"oscht, die "alter sind als die GVT. Das ist m"oglich, da sie nur f"ur den Fall eines Rollbacks
gespeichert wurden. Es kann aber keinen Rollback hinter die GVT geben. Auf diese Weise wird regelm"a\ss ig wieder Platz
in den Dequeues freigegeben, die ja nur ein limitiertes Fassungsverm"ogen haben.

\subsection{Rollback}
\label{subsec:Rollback}
Der Rollback ist die zentrale Funktion des Timewarp Algorithmus. Beim Rollback m"ussen zun"achst alle Zust"ande in der
State-Queue ab dem gegebenen Zeitstempel gel"oscht werden. Anschlie\ss end werden alle Antievents der Output-Queue ab
diesem Zeitstempel verschickt. Dann werden s"amtliche Nachrichten, die noch im Heap stehen, gel"oscht. Dabei m"ussen
alle Events vor dem L"oschen mit einem NACK beantwortet werden.

\chapter{Fazit}
\begin{thebibliography}{10}
\bibitem{timewarp}
Brian Mirtich. Timewarp Rigid Body Simulation. MERL - A MITSUBISHI ELECTRIC RESEARCH LABORATORY

\bibitem{timewarp-cpu}
John Koenig. Object-Centric Parallel Rigid Body Simulation With Timewarp. University of Minnesota

\bibitem{jefferson}
David R. Jefferson. Virtual time. ACM Transactions on Programming Languages and Systems, 7(3):404–425, July 1985.
\end{thebibliography}
\end{document}



